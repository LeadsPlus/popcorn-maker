<!DOCTYPE HTML>
<html lang="en-US">
	<head>
		<meta charset="UTF-8">
		<title></title>
		<script type="text/javascript">
		//see if we need to emulate input[type=range]
		(function(){
			var test = document.createElement('input');
			test.type = 'range';
			if (test.type !== 'range') {
				document.write('<script type="text/javascript" src="js/html5slider.js"><' + '/script>');
			}
		}());
		</script>
		<!--
		
		I suppose you'll want to load butter.js here, but maybe it's more efficient to first try to grab window.parent.Butter
		
		-->
		<script type="text/javascript" src="../../../../lib/butter.js"></script>
		<style type="text/css">
		
		body, fieldset {
			background-color: rgba(0, 0, 0, 0.5);
			font-family: arial;
			color: white;
		}
		
		#instructions {
			background-color: rgba(255, 255, 255, 0.5);
			padding: 2px;
			font-size: 0.9em;
			color: black;
		}
		input[type=range] {
			width: 100%;
		}
		
		input[type=text].small {
			width: 60px;
		}
		
		</style>
	</head>
	<body>
		<div id="form">
			<fieldset>
				<label for="start">From:</label>
				<input type="text" id="start" class="small"/>

				<label for="end">To:</label>
				<input type="text" id="end" class="small"/>
			</fieldset>

			<fieldset id="target-fieldset">
				<label for="target">Target:</label>
				<select id="target"></select>
			</fieldset>

			<fieldset>
				<label for="clipBlack">Clip Black:</label>
				<input type="range" id="clipBlack" min="0" max="1" step="0.0001" value="0.1"></select>
			</fieldset>

			<fieldset>
				<label for="clipWhite">Clip White:</label>
				<input type="range" id="clipWhite" min="0" max="1" step="0.0001" value="0.9"></select>
			</fieldset>

			<fieldset>
				<!-- <input type="button" value="Cancel" id="cancel"/> -->
				<input type="button" value="OK" id="ok"/>
				<!-- <input type="button" value="Apply" id="apply"/> -->
				<input type="button" value="Delete" id="delete"/>
			</fieldset>
		</div>
		<script type="text/javascript">
		
		(function() {
			var trackEvent = {}, targets = [],
				elements = {},
				undoStack = [],
				ids = [
					'start', 'end',
					'target', 'target-fieldset', 'clipBlack', 'clipWhite',
					'cancel', 'ok', 'apply', 'delete'
				];
			
			function saveToStack() {
				var i, state = {};
				for (i in trackEvent) {
					state[i] = trackEvent[i];
				}
				undoStack.push(state);
			}
			
			function undo() {
				if (!undoStack.length) {
					return;
				}

				trackEvent = undoStack.pop();
				if (!undoStack.length) {
					saveToStack();
				}
			}
			
			function reset() {
				if (!undoStack.length) {
					return;
				}

				trackEvent = undoStack[0];
				undoStack.splice(0, undoStack.length);
				saveToStack();
			}

			function checkTime(event) {
				//todo: SMTPE format

				var id = this.id,
					other, compare, otherId, otherElement,
					element, value;

				if (id === 'start') {
					other = trackEvent.end;
					otherId = 'end';
					compare = 1;
				} else if (id === 'end') {
					other = trackEvent.start;
					compare = -1;
					otherId = 'start';
				} else {
					return;
				}
				
				element = elements[id];
				otherElement = elements[otherId];
				value = parseFloat(element.value);
				
				if (isNaN(value) ||
					value < 0
					//todo: || value > duration
					) {

					element.style.backgroundColor = '#f11';
				} else if (value * compare > other * compare) {
					element.style.backgroundColor = '#f11';
					otherElement.style.backgroundColor = '#f11';

					//trackEvent[id] = value;

				} else {
					element.style.backgroundColor = '';
					otherElement.style.backgroundColor = '';

					trackEvent[id] = value;
					
					//todo: if element does not have focus, update element.value
				}
			}
			
			function numbersOnly(event) {
				var e = event || window.event,
					key = e.keyCode || e.which,
					ch = String.fromCharCode(key),
					s;
				
				function blockKey() {
					if (e.preventDefault) {
						e.preventDefault();
					}
					if (e.stopPropagation) {
						e.stopPropagation();
					}
					e.returnValue = false;
					e.cancelBubble = true;
					return false;
				}
				
				if (key === 190) {
					key = 0x2E;
					ch = '.';
				}

				if (e.metaKey || e.altKey || key < 0x21 ||
					e.keyLocation ||
					!e.shiftKey && key <0x27 && ch !=='.') {
					return;
				}
				
				s = this.value;
				if (this.selectionStart !== this.selectionEnd) {
					s = s.substring(0, this.selectionStart) + s.substring(this.selectionEnd, s.length);
				}

				if (ch === '.') {
					s = this.value;
					if (s.indexOf('.') >= 0) {
						return blockKey();
					}
					
					return true;
				}

				ch = parseInt(ch, 10);
				if (isNaN(ch)) {
					return blockKey();
				}
				
			}

			function saveEverything() {
				/*
					everything should already be saved by their own event handlers
				*/
				
				if (window.localStorage) {
					localStorage.clipBlack = trackEvent.clipBlack;
					localStorage.clipWhite = trackEvent.clipWhite;
				}
				
				saveToStack();

				if (client) {
					client.send( trackEvent, "applyclicked" );
				}
			}
			
			function targetsUpdated( newTargets ) {
				var i, select, option, parent, target, validTarget = true;

				targets = newTargets || [];

				try {
					parent = window.parent && window.parent.document;
					parent = parent.getElementById('main').contentDocument;
				} catch (e) {
					parent = false;
				}
				
				if (parent) {
					//only use valid targets that either contain or are canvases
					for (i = 0; i < targets.length; i++) {					
						target = parent.getElementById(targets[i][0]);

						if (!target ||
							!(target.tagName === 'CANVAS' || target.getElementsByTagName('canvas').length)) {
							
							targets.splice(i, 1);
							i--;
						}
					}
				}
				
				if (targets.length <= 1) {
					elements['target-fieldset'].style.display = 'none';

					if (targets.length) {
						trackEvent.target = targets[0][0];
					}
				} else {
					elements['target-fieldset'].style.display = '';
					select = elements.target;
					//select.innerHTML = '<option>Default</option>';
					
					try {
						parent = window.parent && window.parent.document;
						parent = parent.getElementById('main').contentDocument;
					} catch (e) {
						parent = false;
					}
					
					for (i = 0; i < targets.length; i++) {
						
						option = document.createElement('option');
						option.value = targets[i][0];
						option.appendChild( document.createTextNode(targets[i][0]) );
						select.appendChild(option);

						if (targets[i][0] === trackEvent.target) {
							option.selectedIndex = i;
						}
					}
				}
			}
			
			function editTrackEvent( popcornOptions ) {
				trackEvent = popcornOptions;
				//todo: https://webmademovies.lighthouseapp.com/projects/65733/tickets/194-editor-dialogs-should-show-frame-accurate-times
				
				//todo: I'd also like to have the video duration so I can error-check against that as well.
				if (isNaN(trackEvent.start) || trackEvent.start < 0) {
					trackEvent.start = 0;
				}
				elements.start.value = trackEvent.start;

				if (isNaN(trackEvent.end) || trackEvent.end < trackEvent.start) {
					trackEvent.start = trackEvent.start + 5;
				}
				elements.end.value = trackEvent.end;

				if (targets.length) {
					var matchTargets = targets.filter(function(t) {
						return t[0] === trackEvent.target;
					});
					if (!trackEvent.target || !matchTargets.length) {
						trackEvent.target = targets[0][0];
					}
				} else {
					trackEvent.target = '';
				}
				elements.target.value = trackEvent.target;
				
				if (trackEvent.clipBlack === undefined || isNaN(trackEvent.clipBlack)) {
					if (window.localStorage &&
						localStorage.clipBlack !== undefined &&
						!isNaN(localStorage.clipBlack)) {
						
						trackEvent.clipBlack = localStorage.clipBlack;
					} else {
						trackEvent.clipBlack = 0;
					}
				}
				
				if (trackEvent.clipWhite === undefined || isNaN(trackEvent.clipWhite)) {
					if (window.localStorage &&
						localStorage.clipWhite !== undefined &&
						!isNaN(localStorage.clipWhite)) {
						
						trackEvent.clipWhite = localStorage.clipWhite;
					} else {
						trackEvent.clipWhite = 0;
					}
				}
				
				trackEvent.clipBlack = Math.max(0, Math.min(1, trackEvent.clipBlack));
				trackEvent.clipWhite = Math.max(0, Math.min(1, trackEvent.clipWhite));
				
				if (trackEvent.clipWhite < trackEvent.clipBlack) {
					var temp = trackEvent.clipWhite;
					trackEvent.clipWhite = trackEvent.clipBlack;
					trackEvent.clipBlack = temp;
				}
				
				elements.clipBlack.value = trackEvent.clipBlack;
				elements.clipWhite.value = trackEvent.clipWhite;
				
				reset();
			}
			
			function initialize() {
				var i;

				//set up a default trackEvent, even though this will probably be replaced
				trackEvent = {
					start: 0,
					end: 5,
					clipBlack: 0,
					clipWhite: 1
				};

				//set up butter
				if (window.Butter) {
					butter = new Butter();
					butter.comm();
					client = new butter.CommClient('defaultEditor');
	
					client.listen('edittrackevent', function (message) {
						client.send( {
							width: 400,
							height: 260
						}, 'clientdimsupdated' );

						targetsUpdated(message.targets);
						editTrackEvent(message.trackEvent.popcornOptions);
					});
	
					client.listen( "domtargetsupdated", function( message ) {
						targetsUpdated(message);
					});
				}

				for (i = 0; i < ids.length; i++) {
					elements[ ids[i] ] = document.getElementById(ids[i]);
				}
				
				elements.start.addEventListener('change', checkTime, false);
				elements.start.addEventListener('keyup', checkTime, true);

				elements.end.addEventListener('change', checkTime, false);
				elements.end.addEventListener('keyup', checkTime, true);
				
				elements.target.addEventListener('change', function() {
					if (targets.indexOf(elements.target.value) > -1) {
						trackEvent.target = elements.target.value;
					}
					saveEverything();
				}, false);
				
				elements.clipBlack.addEventListener('change', function() {
					trackEvent.clipBlack = this.value;
					
					if (trackEvent.clipWhite < trackEvent.clipBlack) {
						trackEvent.clipWhite = trackEvent.clipBlack;
						elements.clipWhite.value = trackEvent.clipWhite;
					}
					
					saveEverything();
				}, false);
				
				elements.clipWhite.addEventListener('change', function() {
					trackEvent.clipWhite = this.value;

					if (trackEvent.clipBlack > trackEvent.clipWhite) {
						trackEvent.clipBlack = trackEvent.clipWhite;
						elements.clipBlack.value = trackEvent.clipBlack;
					}
					
					saveEverything();
				}, false);
				
				//buttons
/*
				elements.cancel.addEventListener('click', function() {
					//tell butter we've cancelled
					if (client) {
						client.send( '', 'cancelclicked');
					}
				}, false);
*/
				elements['delete'].addEventListener('click', function() {
					//tell butter to delete
					if (client) {
						client.send( '', 'deleteclicked');
					}
				}, false);
/*
				elements.apply.addEventListener('click', function() {
					saveEverything();
					//send back to Butter
					if (client) {
						client.send( trackEvent, "applyclicked" );
					}
				}, false);
*/
				elements.ok.addEventListener('click', function() {
					saveEverything();
					//send back to Butter and close
					if (client) {
						client.send( trackEvent, "okayclicked" );
					}
				}, false);				
			}
			
			initialize();

		}());
		</script>
	</body>
</html>