<!DOCTYPE HTML>
<html lang="en-US">
	<head>
		<meta charset="UTF-8">
		<title></title>
		<!--
		
		I suppose you'll want to load butter.js here, but maybe it's more efficient to first try to grab window.parent.Butter
		
		-->
		<script type="text/javascript" src="../../../../lib/butter.js"></script>
		<style type="text/css">
		
		body, fieldset {
			background-color: rgba(0, 0, 0, 0.5);
			font-family: arial;
			color: white;
		}
		
		#instructions {
			background-color: rgba(255, 255, 255, 0.5);
			padding: 2px;
			font-size: 0.9em;
			color: black;
		}
		input[type=text] {
			width: 100%;
		}
		
		input[type=text].small {
			width: 60px;
		}
		
		textarea {
			display: block;
			width: 100%;
			height: 6em;
		}
		
		</style>
	</head>
	<body>
		<div id="form">
			<fieldset>
				<label for="start">From:</label>
				<input type="text" id="start" class="small"/>

				<label for="end">To:</label>
				<input type="text" id="end" class="small"/>
			</fieldset>

			<fieldset id="target-fieldset">
				<label for="target">Target:</label>
				<select id="target"></select>
			</fieldset>

			<fieldset>
				<label style="font-weight: bold">Position</label><br/>
				<label for="left">Left:</label>
				<input type="text" id="left" class="small"/>%

				<label for="top">Top:</label>
				<input type="text" id="top" class="small"/>%
			</fieldset>

			<fieldset>
				<label for="html">HTML:</label>
				<textarea id="html"></textarea>
			</fieldset>

			<fieldset>
				<label for="lightbox">Lightbox Contents (HTML):</label>
				<textarea id="lightbox"></textarea>
			</fieldset>

			<fieldset>
				<input type="button" value="Cancel" id="cancel"/>
				<input type="button" value="OK" id="ok"/>
				<input type="button" value="Apply" id="apply"/>
				<input type="button" value="Delete" id="delete"/>
			</fieldset>
		</div>
		<script type="text/javascript">
		
		(function() {
			var trackEvent = {}, targets = [],
				elements = {},
				undoStack = [],
				left, top,
				ids = [
					'start', 'end',
					'target', 'target-fieldset', 'html', 'lightbox', 'left', 'top',
					'cancel', 'ok', 'apply', 'delete'
				];
			
			function saveToStack() {
				var i, state = {};
				for (i in trackEvent) {
					state[i] = trackEvent[i];
				}
				undoStack.push(state);
			}
			
			function undo() {
				if (!undoStack.length) {
					return;
				}

				trackEvent = undoStack.pop();
				if (!undoStack.length) {
					saveToStack();
				}
			}
			
			function reset() {
				if (!undoStack.length) {
					return;
				}

				trackEvent = undoStack[0];
				undoStack.splice(0, undoStack.length);
				saveToStack();
			}

			function checkTime(event) {
				//todo: SMTPE format

				var id = this.id,
					other, compare, otherId, otherElement,
					element, value;

				if (id === 'start') {
					other = trackEvent.end;
					otherId = 'end';
					compare = 1;
				} else if (id === 'end') {
					other = trackEvent.start;
					compare = -1;
					otherId = 'start';
				} else {
					return;
				}
				
				element = elements[id];
				otherElement = elements[otherId];
				value = parseFloat(element.value);
				
				if (isNaN(value) ||
					value < 0
					//todo: || value > duration
					) {

					element.style.backgroundColor = '#f11';
				} else if (value * compare > other * compare) {
					element.style.backgroundColor = '#f11';
					otherElement.style.backgroundColor = '#f11';

					//trackEvent[id] = value;

				} else {
					element.style.backgroundColor = '';
					otherElement.style.backgroundColor = '';

					trackEvent[id] = value;
					
					//todo: if element does not have focus, update element.value
				}
			}
			
			function numbersOnlyNeg(event) {
				var e = event || window.event,
					key = e.keyCode || e.which,
					ch = String.fromCharCode(key),
					s;
				
				function blockKey() {
					if (e.preventDefault) {
						e.preventDefault();
					}
					if (e.stopPropagation) {
						e.stopPropagation();
					}
					e.returnValue = false;
					e.cancelBubble = true;
					return false;
				}
				
				if (key === 190) {
					key = 0x2E;
					ch = '.';
				}

				if (e.metaKey || e.altKey || key < 0x21 ||
					e.keyLocation ||
					!e.shiftKey && key <0x27 && ch !=='.' &&
						ch !== '-' && key !== 189 && key !== 109) {
					return;
				}
				
				s = this.value;
				if (this.selectionStart !== this.selectionEnd) {
					s = s.substring(0, this.selectionStart) + s.substring(this.selectionEnd, s.length);
				}

				if (key === 189 || ch === '-' || key === 109) {
					if (this.selectionStart) {
						return blockKey();
					}

					if (s.indexOf('-') >= 0) {
						return blockKey();
					}
					
					return true;
				}

				if (ch === '.') {
					s = this.value;
					if (s.indexOf('.') >= 0) {
						return blockKey();
					}
					
					return true;
				}

				ch = parseInt(ch, 10);
				if (isNaN(ch)) {
					return blockKey();
				}
				
				if (s.indexOf('-') >= this.selectionStart) {
					return blockKey();
				}
			}
			
			function numbersOnly(event) {
				var e = event || window.event,
					key = e.keyCode || e.which,
					ch = String.fromCharCode(key),
					s;
				
				function blockKey() {
					if (e.preventDefault) {
						e.preventDefault();
					}
					if (e.stopPropagation) {
						e.stopPropagation();
					}
					e.returnValue = false;
					e.cancelBubble = true;
					return false;
				}
				
				if (key === 190) {
					key = 0x2E;
					ch = '.';
				}

				if (e.metaKey || e.altKey || key < 0x21 ||
					e.keyLocation ||
					!e.shiftKey && key <0x27 && ch !=='.') {
					return;
				}
				
				s = this.value;
				if (this.selectionStart !== this.selectionEnd) {
					s = s.substring(0, this.selectionStart) + s.substring(this.selectionEnd, s.length);
				}

				if (ch === '.') {
					s = this.value;
					if (s.indexOf('.') >= 0) {
						return blockKey();
					}
					
					return true;
				}

				ch = parseInt(ch, 10);
				if (isNaN(ch)) {
					return blockKey();
				}
				
			}

			function saveEverything() {
				/*
					everything should already be saved by their own event handlers
				*/
				
				saveToStack();
				trackEvent.left = elements.left.value + '%';
				trackEvent.top = elements.top.value + '%';

			}
			
			function targetsUpdated( newTargets ) {
				var i, select, option, parent, target, validTarget = true;

				targets = newTargets || [];

				if (targets.length <= 1) {
					elements['target-fieldset'].style.display = 'none';

					if (targets.length) {
						trackEvent.target = targets[0][0];
					}
				} else {
					elements['target-fieldset'].style.display = '';
					select = elements.target;
					//select.innerHTML = '<option>Default</option>';
					
					try {
						parent = window.parent && window.parent.document;
						parent = parent.getElementById('main').contentDocument;
					} catch (e) {
						parent = false;
					}
					
					for (i = 0; i < targets.length; i++) {
						
						option = document.createElement('option');
						option.value = targets[i][0];
						option.appendChild( document.createTextNode(targets[i][0]) );
						select.appendChild(option);

						if (targets[i][0] === trackEvent.target) {
							option.selectedIndex = i;
						}
					}
				}
			}
			
			function editTrackEvent( popcornOptions ) {
				trackEvent = popcornOptions;
				//todo: https://webmademovies.lighthouseapp.com/projects/65733/tickets/194-editor-dialogs-should-show-frame-accurate-times
				
				//todo: I'd also like to have the video duration so I can error-check against that as well.
				if (isNaN(trackEvent.start) || trackEvent.start < 0) {
					trackEvent.start = 0;
				}
				elements.start.value = trackEvent.start;

				if (isNaN(trackEvent.end) || trackEvent.end < trackEvent.start) {
					trackEvent.start = trackEvent.start + 5;
				}
				elements.end.value = trackEvent.end;

				if (targets.length) {
					var matchTargets = targets.filter(function(t) {
						return t[0] === trackEvent.target;
					});
					if (!trackEvent.target || !matchTargets.length) {
						trackEvent.target = targets[0][0];
					}
				} else {
					trackEvent.target = '';
				}
				elements.target.value = trackEvent.target;
				
				elements.html.value = trackEvent.html || '';
				elements.lightbox.value = trackEvent.lightbox || '';
				
				left = parseFloat(trackEvent.left) || 0;
				top = parseFloat(trackEvent.top) || 0;
				elements['left'].value = left;
				elements['top'].value = top;

				reset();
			}
			
			function initialize() {
				var i;

				//set up a default trackEvent, even though this will probably be replaced
				trackEvent = {
					start: 0,
					end: 5
				};

				//set up butter
				if (window.Butter) {
					butter = new Butter();
					butter.comm();
					client = new butter.CommClient('defaultEditor');
	
					client.listen('edittrackevent', function (message) {
						client.send( {
							width: 500,
							height: 420
						}, 'clientdimsupdated' );

						targetsUpdated(message.targets);
						editTrackEvent(message.trackEvent.popcornOptions);
					});
	
					client.listen( "domtargetsupdated", function( message ) {
						targetsUpdated(message);
					});
				}

				for (i = 0; i < ids.length; i++) {
					elements[ ids[i] ] = document.getElementById(ids[i]);
				}
				
				elements.start.addEventListener('change', checkTime, false);
				elements.start.addEventListener('keyup', checkTime, true);

				elements.end.addEventListener('change', checkTime, false);
				elements.end.addEventListener('keyup', checkTime, true);
				
				elements.top.addEventListener('keydown', numbersOnlyNeg, true);
				elements.left.addEventListener('keydown', numbersOnlyNeg, true);

				elements.target.addEventListener('change', function() {
					var t = targets.filter(function(item) {
						return item[0] === elements.target.value;
					});
					if (t.length) {
						trackEvent.target = elements.target.value;
					}
					saveEverything();
				}, false);
				
				elements.html.addEventListener('keyup', function () {
					trackEvent.html = this.value;
					saveEverything();
				}, false);
				
				elements.lightbox.addEventListener('keyup', function () {
					trackEvent.lightbox = this.value;
					saveEverything();
				}, false);
				
				//buttons
				elements.cancel.addEventListener('click', function() {
					//tell butter we've cancelled
					if (client) {
						client.send( '', 'cancelclicked');
					}
				}, false);

				elements['delete'].addEventListener('click', function() {
					//tell butter to delete
					if (client) {
						client.send( '', 'deleteclicked');
					}
				}, false);

				elements.apply.addEventListener('click', function() {
					saveEverything();
					//send back to Butter
					if (client) {
						client.send( trackEvent, "applyclicked" );
					}
				}, false);

				elements.ok.addEventListener('click', function() {
					saveEverything();
					//send back to Butter and close
					if (client) {
						client.send( trackEvent, "okayclicked" );
					}
				}, false);				
			}
			
			initialize();

		}());
		</script>
	</body>
</html>